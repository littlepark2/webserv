<Config Code logic>

1. directive를 읽는다.
  1.1. directive에 구분자('{', '}' 또는 ';') 가 있으면
    1.1.1. 구분자 문자를 시작으로 하는 문자열을 담는 config stream을 구한다.
    1.1.2. 구분자 이전 문자열을 directive 문자열에 저장하다.
2. directive가 해당(Main, Server, Location)디렉티브가 아니면 예외를 던지다.
3. parameter 종료 문자를 구하다.
4. parameter 벡터 문자열을 구한다.
5. parameter 문자열에 구분자가 있으면 예외를 던진다.
6. parameter 개수가 directive에 맞지 않으면 예외를 던진다.
7. 각 parameter 문자열이 directive parameter 형태에 맞지 않으면 예외를 던진다.
8. 해당 directive가 block directive 인지 simple directive인지 확인하다.
  8.1. 블록 디렉티브이면
    8.1.1. 스트림의 첫문자가 '{'가 아니면 예외를 던진다.
    8.1.2. 블록 문자열을 구한다.
    8.1.3. 블록 문자열을 생성자 매게변수로 가지는 하위 객체를 생성한다.
    8.1.4. 생성된 하위 객체를 하위 객체 컨테이너에 담는다. 
9. directive를 초기화하다.

<Config 구성 요소>

1. 디렉티브
2. 파라메터

<Config 필요 기능>

1. 디렉티브 파싱
	1.1. 디렉티브 읽기
	1.2. 디렉티브 유효성 확인
	1.3. 디렉티브 속성(블록 or simple) 확인
2. 파라메터 파싱
	2.1. 파라메터 읽기
	2.2. 파라메터 구분자 있는지 확인
	2.3. 파라메터 문자열 구하기
	2.4. 파라메터 개수 확인하기
	2.5. 디렉티브가 블록 디렉티브이면, 블록 읽기

3. 파싱 정보 저장
4. 저장 정보 반환

<Config 필요 클래스>

1. ConfigParser
2. ConfigBase

<Url path에 대한 적정 location 찾기 code logic>

1. URL path를 입력받는다.
2. URL path와 일치하는 location이 있는지 확인하다.
	2.1. 있으면 해당 iterator값을 반환하다.
3. location 중에 path(key값)가 '~.php'와 같이 특정 문자열로 끝나는 것이 있는지 확인하다.
	3.1. 있으면 해당 location key값('.php')이 URL path에 있는지 확인한다.
		3.1.1. 있으면 해당 location iterator 값을 반환하다.
4. location 맵의 처음부터 끝까지 반복한다.
	4.1. location 키를 구한다.
	4.2. location 키값 문자열 길이 만큼 URL 경로 문자열의 처음부분과 같은지를 확인하다.
		4.2.1. 같으면 기존 가장 긴 문자열 길이보다 해당 키값이 더 큰지를 확인하다.
			4.2.1.1. 더 크면 해당 키값의 길이를 가장긴 문자열 길이로 하다.
			4.2.1.2. 해당 반복자를 best 반복자로 하다.
5. best반복자를 반환하다.(못찾을 경우 best 반복자 초기값 end 값 반환)

//CGI Executor 부분//

1. location과 protocol을 입력받는다.
2. CGI실행 디렉토리를 구하다.
3. 환경변수(SCRIPT_NAME, PATH_INFO, REQUEST_METHOD 등)를 구한다.
4. CGI 파일을 입력받는다.
5. 파이트 파일 디스크립터를 생성한다.
6. 자식 프로세스를 생성한다.
7. 파이프 디스크립터로 설정한다.
5. CGI 파일을 실행한다.